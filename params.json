{"name":"PyRackDS","tagline":"Templating engine for Racktables data","body":"pyRackDS\r\n========\r\n\r\nPython data services for [Racktables](http://github.com/RackTables/racktables).\r\n\r\n# What does it do?\r\n\r\nThis package is intended to, ultimately, be a two-way interface to:\r\n* use data from [Racktables](http://github.com/racktables/racktables) to create different kinds of configuration files, and\r\n* use third-party applications to pump data into [Racktables](http://github.com/racktables/racktables) (such as facter)\r\n\r\nCurrently this heavily relies on the work of [Ian Bettinger](https://github.com/ibettinger) from which I borrow both, the PHP-based [Racktables-API](https://github.com/ibettinger/racktables) and the corresponding [Python module](https://github.com/ibettinger/racktables-py-client) to consume the data.\r\n\r\nWhat you will get is a well documented, Python-dictionary based way of creating files via the Cheetah templating engine. This by itself is sufficient to create e.g.\r\n\r\n* Puppet node definitions\r\n* Cobbler system registrations\r\n* Nagios / Icinga configurations\r\n\r\nThose templates are supplied as examples how to use both, the templating engine and the definitions to create the files needed to run the service(s).\r\n\r\npyRackDS is fully customizable and I've spent enough time documenting the iterations for you to extend it. Need information about the asset tag? Just add it to the tree … I thought about making the content of the tree configurable -- but given the expected audience I decided against it. Hacking a couple of lines in Python will get you there goal anyway.\r\n\r\n# How do I use it?\r\n\r\nJust clone the repository. It's all there, including examples how to use the templating engine. There are 3 dictionary trees:\r\n\r\n- allHosts\r\n- allNetworks\r\n- allTags\r\n\r\nA detailled description with example data will be made available soon.\r\n\r\nTo activate a template, you need 2 things:\r\n\r\n- the template (surprise)\r\n(ending in **.tmpl** in the **templates.d** directory)\r\n- a definition (*surprise!*)\r\n(ending in **.cfg** in the **definitions.d** directory)\r\n\r\nThe definition is mainly there to some more flexibility in the way you can create files. It'll give you the option to specify\r\n\r\n- a target directory with the variable **outputdir** (such as /etc/puppet/manifests/nodes)\r\n- a file extension with the variable **extension** (such as .pp)\r\n- burst mode (*what?*) with the variable **burst**\r\n\r\n## Burst mode\r\n\r\nThis is tricky. And the name might be confusing - but it works for me. I wanted to not only be able to run through the template with all the trees at once, but for each object in a specific tree as well. This gives you the ability to create one file per host, per network, per tag (you get the idea). Currently available *burst modes* are:\r\n\r\n- **none** (default)\r\n(available dictionaries: *allHosts, allNetworks, allTags*)\r\n- hosts\r\n(available dictionary: *host*)\r\n- networks\r\n(available dictionary: *network*)\r\n- tags\r\n(available dictionary: *tag*)\r\n- tftp\r\n(available dictionary: *iface*)\r\n\r\nFor burst mode *none*, the output file will be named like the template, with the ending specified in the definition (mytemplate.tmpl with mytemplate.cfg will create mytemplate.extension). For all other burst methods, the files will be named like the subelement-name followed by the extension. For hosts, this means you get:\r\n\r\n- hostname1.pp\r\n- hostname2.pp\r\n- hostname3.pp\r\n\r\nThe definition uses the default Python *ConfigParser* module and therefore looks like an ini-style configuration:\r\n\r\n    [definition]\r\n    outputdir = /var/tmp/puppet/\r\n    extension = .pp\r\n    burst = hosts\r\n\r\nThe configuration option *extension* is optional (aka not used) for burst methode *tftp*\r\n\r\n\r\n# Configuring pyRackDS\r\n\r\npyRackDS only needs some minor configuration, thus, basically, the API URL plus username and password. It's stored in the *conf* directory and named *main.cfg*:\r\n\r\n    [main]\r\n    apiurl = \"http://racktables/api.php\"\r\n    username = admin\r\n    password = mypassword\r\n\r\n    [tags]\r\n    puppet_parent = puppet\r\n    cobbler_parent = cobbler\r\n\r\nThe two additional configurations are specific to the main purpose - configuration management. You need to specify the parent tag names for puppet and cobbler tags.\r\n\r\nThe *puppet* parent tag is for assigning one or multiple *puppet* classes to a node.\r\n\r\nThe *cobbler* tag is to assign a *cobbler* profile. At least that's how I implemented it. Change it as you like - as I said - it's easily customizable and should ideally serve whatever use-case you need.\r\n\r\n# License\r\n\r\nCopyright (c) 2013 Thomas Uhde\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n# Contributors\r\n\r\n[Thomas Uhde](https://github.com/acidix), [Christian Schwarz](https://github.com/T-002)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}