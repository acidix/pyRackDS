#!/usr/bin/env python

import ipaddress
import sys,os,inspect,ConfigParser
from pprint import pprint
from Cheetah.Template import Template

racklib = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],"../python/lib/racktables")))
sys.path.insert(0, racklib)
from client import *

def calcDottedNetmask(mask):
    bits = 0
    for i in xrange(32-mask,32):
        bits |= (1 << i)
    return "%d.%d.%d.%d" % ((bits & 0xff000000) >> 24, (bits & 0xff0000) >> 16, (bits & 0xff00) >> 8 , (bits & 0xff))


# Read Configuration
configdir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],"../conf")))
config = ConfigParser.ConfigParser()
config.readfp(open(configdir + '/main.cfg'))

templatedir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],"../templates.d")))
definitiondir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],"../definitions.d")))

# Open the client api
rtClient = RacktablesClient(config.get('main', 'apiurl').strip('"'), config.get('main', 'username'), config.get('main', 'password'))

# Initialize Trees
allNetworks = {}
allHosts = {}
allTags = {
	'puppet_tags' : [],
	'cobbler_tags': [],
	'other_tags'  : []
}

######## Populate all ipv4 networks ########

# Initialize the Network tree
rtNetworks = rtClient.get_ipv4space()


for rtNetworkIdx, rtNetwork in rtNetworks.items():
	allNetworks[rtNetwork['id']] = { 
		'id' 		: rtNetwork['id'], 
		'ip' 		: rtNetwork['ip'], 
		'mask' 		: calcDottedNetmask(int(rtNetwork['mask'])), 
		'name' 		: rtNetwork['name'],
		'comment'	: rtNetwork['comment'],
		'static'	: {},
		'dynamic'	: {}
	}

######## Populate all hosts ########

# Initialize the Hosts tree
rtHosts = rtClient.get_objects()

for rtHostIdx, rtHost in rtHosts.items():
	allHosts[rtHost['id']] = {	
		'id' 		      : rtHost['id'],
		'name'		      : rtHost['name'],
		'dname'		      : rtHost['dname'],
		'label'		      : rtHost['label'],
		'objtype_id'      : rtHost['objtype_id'],
		'ifaces'	      : {},
		'comment'         : rtHost['comment'],
		'puppet_tags'     : [],
		'other_tags'      : [],
		'cobbler_profile' : ""
	}

	rtHostInfos = rtClient.get_object(rtHost['id'])

	# Add tags
	for etagidx, etag in rtHostInfos['etags'].items():
		if etag['parent_id'] != "":
			if rtHostInfos['itags'][etag['parent_id']]['tag'] == config.get('tags', 'puppet_parent'):
				allHosts[rtHost['id']]['puppet_tags'].append(etag['tag'])
			elif rtHostInfos['itags'][etag['parent_id']]['tag'] == config.get('tags', 'cobbler_parent'):
				allHosts[rtHost['id']]['cobbler_profile'] = etag['tag']
			else:
				allHosts[rtHost['id']]['other_tags'].append(etag['tag'])
		else :
			allHosts[rtHost['id']]['other_tags'].append(etag['tag'])

	# Add network information to host
	# Loop over all ipv4 objects of the host
	for rtHostInfoIdx, rtHostInfo in rtHostInfos['ipv4'].items():
		# For multiple assignments to one address, all interface assigned are reported.
		# This is to loop over all interfaces allocated to this address and then find
		# the one that matches our object_id
		for rtHostAllocIdx, rtHostAlloc in rtHostInfo['addrinfo']['allocs'].items():
			if (rtHostAlloc['object_id'] == rtHost['id']):
				allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']] = {	
					'name'	: rtHostAlloc['name'],
					'addr'	: rtHostInfo['addrinfo']['ip']
				}
				# Add L2 address info to each interface with an IP
				# This information is located in a different tree (ports)
				for rtHostLinkIdx, rtHostLink in rtHostInfos['ports'].items():
					if (rtHostLink['name'] == rtHostAlloc['name']):
						allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']]['mac'] = rtHostLink['l2address']
						allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']]['fqdn'] = rtHostLink['label']

				# Add network information to the network tree
				# We have to loop over all known Networks to see where we belong to
				for NetworkIdx, Network in allNetworks.items():
					NetworkAddr = allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']]['addr']
					NetworkObj = Network['ip'] + '/' + Network['mask']

					# Add static assignments
					# Check if our address belongs to the network, but is not the network address itself
					if ( ( ipaddress.ip_address(NetworkAddr) in ipaddress.ip_network(NetworkObj) ) and ( NetworkAddr != Network['ip'] ) ):
						try:
							# First, add the netmask to the host
							allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']]['mask'] = Network['mask']

							# Now, add the host information to the network tree
							_iface = allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']]['name']
							_addr  = allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']]['addr']
							_fqdn  = allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']]['fqdn']
							_mac   = allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']]['mac']
							# Check if all values are set, otherwise our config will look mangled
							if ( _addr and _fqdn and _mac ):
								allNetworks[Network['id']]['static'][allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']]['fqdn']] = {
									'iface'	: _iface,
									'addr'	: _addr,
									'fqdn'	: _fqdn,
									'mac'	: _mac
								}
						except KeyError:
							continue
					# Add dynamic assignments - allocations on the network address
					# Allocate IP = Network address to put the host into a dynamic range
					elif (NetworkAddr == Network['ip']):
						try:
							_iface = allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']]['name']
							_fqdn  = allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']]['fqdn']
							_mac   = allHosts[rtHost['id']]['ifaces'][rtHostAlloc['name']]['mac']
							# Check if all values are set, otherwise our config will look mangled
							if ( _fqdn and _mac ):
								allNetworks[Network['id']]['dynamic'][allHosts[rtHost[1]['id']]['ifaces'][rtHostAlloc[1]['name']]['fqdn']] = {
									'iface'	: _iface,
									'fqdn'	: _fqdn,
									'mac'	: _mac
								}
						except KeyError:
							continue


######## Populate all tags ########

# Initialize the Tag tree
rtTags = rtClient.get_tags(True)

for rtTagIdx, rtTag in rtTags.items():
	if rtTag['kidc'] == 0:
		# If the tag doesn't have childs, just add it to other_tags
		allTags['other_tags'].append(rtTag.tag)
	else:
		if rtTag['tag'] == config.get('tags', 'puppet_parent'):
			# Add all kids of the puppet tree to puppet_tags
			for rtTagKidIdx, rtTagKid in rtTag['kids'].items():
				allTags['puppet_tags'].append(rtTagKid['tag'])
		elif rtTag['tag'] == config.get('tags', 'cobbler_parent'):
			# Add all kids of the cobbler tree to cobbler_tags
			for rtTagKidIdx, rtTagKid in rtTag['kids'].items():
				allTags['cobbler_tags'].append(rtTagKid['tag'])	
		else:
			# This is hierarchical, but neither puppet nor cobbler
			# Flatten and add to other_tags
			allTags['other_tags'].append(rtTag.tag)
			for rtTagKidIdx, rtTagKid in rtTag['kids'].items():
				allTags['other_tags'].append(rtTagKid['tag'])	

# Start the templating process
for dirname, dirnames, filenames in os.walk(templatedir):
	for filename in filenames:
		if filename.split('.')[1] == 'tmpl':
			path = os.path.join(templatedir, filename)
			definition = ConfigParser.ConfigParser()
			definition.readfp(open(definitiondir + '/' + filename.split('.')[0] + '.cfg'))
			# Read Definition
			burst = definition.get('definition', 'burst')
			outputdir = definition.get('definition', 'outputdir')
			# extension is optional for tftp
			try:
				extension = definition.get('definition', 'extension')
			except Exception, errtxt:
				if definition.get('definition', 'burst') == 'tftp':
					pass
				else:
					continue
			if (burst == 'none') or (burst == ''):
				try:
					renderedTemplate = Template( file = path, searchList = [ {'allHosts' : allHosts}, {'allNetworks' : allNetworks}, {'allTags' : allTags} ] )
					outfile = open(outputdir + filename.split('.')[0] + extension, "w")
					outfile.write(str(renderedTemplate))
				except IOError:
					pass
				finally:
					outfile.close()
			# Iterate for Hosts
			elif burst == 'hosts':
				try:
					for hostidx, host in allHosts.items():
						renderedTemplate = Template( file = path, searchList = [ {'host' : host} ] )
						outfile = open(outputdir + host['name'] + extension, "w")
						outfile.write(str(renderedTemplate))
				except IOError:
					pass
				finally:
					outfile.close()
			# Iterate for Networks
			elif burst == 'networks':
				try:
					for networkidx, network in allNetworks:
						renderedTemplate = Template( file = path, searchList = [ {'network' : network} ] )
						outfile = open(outputdir + network['name'] + extension, "w")
						outfile.write(str(renderedTemplate))
				except IOError:
					pass
				finally:
					outfile.close()
			# Iterate for tags
			elif burst == 'tags':
				try:
					for tagidx, tag in allTags:
						renderedTemplate = Template( file = path, searchList = [ {'tag' : tag} ] )
						outfile = open(outputdir + tag['name'] + extension, "w")
						outfile.write(str(renderedTemplate))
				except IOError:
					pass
				finally:
					outfile.close()
			# Iterate for macs
			elif burst == 'tftp':
				try:
					for hostidx, host in allHosts.items():
						for ifaceidx, iface in host['ifaces'].items():
							renderedTemplate = Template( file = path, searchList = [ {'iface' : iface} ] )
							outfile = open(outputdir + iface['mac'].lower().replace(":", "-"), "w")
							outfile.write(str(renderedTemplate))
				except IOError:
					pass
				finally:
					outfile.close()
			else:
				print 'Unknown burst method'




